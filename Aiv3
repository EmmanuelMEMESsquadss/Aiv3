-- Mode indicator - Click to switch bypass methods
modeIndicator.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		if bypassMode then
			-- Cycle through methods
			bypassMethod = bypassMethod + 1
			if bypassMethod > 3 then
				bypassMethod = 1
			end
			
			modeIndicator.Text = "BYP-" .. bypassMethod
			applyBtn.Text = "M" .. bypassMethod
			
			warn("[Speed Customizer] Switched to Bypass Method " .. bypassMethod)
			
			if bypassMethod == 1 then
				debugLabel.Text = "Method 1: BodyVelocity"
			elseif bypassMethod == 2 then
				debugLabel.Text = "Method 2: CFrame"
			else
				debugLabel.Text = "Method 3: Hybrid"
			end
		end
	end
end)-- LocalScript (StarterPlayerScripts)
-- Mobile Speed Customizer with Anti-Protection Bypass

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Only run on mobile
if not UserInputService.TouchEnabled then
	return
end

local player = Players.LocalPlayer
local character, humanoid, hrp

local DEFAULT_SPEED = 16
local currentSpeed = DEFAULT_SPEED
local isSpeedActive = false
local bypassMode = false
local bypassMethod = 2  -- Start with Method 2 (CFrame) as it's more reliable

-- Speed bypass objects
local bodyVelocity
local debugLabel

local function setupCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
	
	-- Store default speed
	if humanoid then
		DEFAULT_SPEED = humanoid.WalkSpeed
	end
	
	-- Clean up old velocity if exists
	if bodyVelocity then
		bodyVelocity:Destroy()
		bodyVelocity = nil
	end
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- GUI
local gui = Instance.new("ScreenGui")
gui.Name = "SpeedCustomizerUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- Main Speed Container (just a visual wrapper)
local speedContainer = Instance.new("Frame")
speedContainer.Size = UDim2.new(0, 140, 0, 135)  -- Increased height for debug label
speedContainer.Position = UDim2.new(0.85, -140, 0.5, -67)
speedContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
speedContainer.BorderSizePixel = 0
speedContainer.Active = false  -- Not interactive itself
speedContainer.Parent = gui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 12)
containerCorner.Parent = speedContainer

-- Drag Handle Area (ONLY for dragging)
local dragHandle = Instance.new("Frame")
dragHandle.Size = UDim2.new(1, 0, 0, 33)
dragHandle.Position = UDim2.new(0, 0, 0, 0)
dragHandle.BackgroundTransparency = 1  -- Invisible, just for dragging
dragHandle.Active = true  -- Can receive input
dragHandle.Parent = speedContainer

-- Title Label (inside drag handle)
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -20, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "SPEED"
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = dragHandle

-- Speed Input Box
local speedInput = Instance.new("TextBox")
speedInput.Size = UDim2.new(1, -20, 0, 35)
speedInput.Position = UDim2.new(0, 10, 0, 38)
speedInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
speedInput.BorderSizePixel = 0
speedInput.Font = Enum.Font.GothamBold
speedInput.TextSize = 20
speedInput.TextColor3 = Color3.new(1, 1, 1)
speedInput.PlaceholderText = "16"
speedInput.Text = ""
speedInput.ClearTextOnFocus = false
speedInput.TextXAlignment = Enum.TextXAlignment.Center
speedInput.Parent = speedContainer

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 8)
inputCorner.Parent = speedInput

-- Apply Button
local applyBtn = Instance.new("TextButton")
applyBtn.Size = UDim2.new(1, -20, 0, 32)
applyBtn.Position = UDim2.new(0, 10, 0, 80)
applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
applyBtn.BorderSizePixel = 0
applyBtn.Font = Enum.Font.GothamBold
applyBtn.TextSize = 14
applyBtn.TextColor3 = Color3.new(1, 1, 1)
applyBtn.Text = "APPLY"
applyBtn.Parent = speedContainer

local applyCorner = Instance.new("UICorner")
applyCorner.CornerRadius = UDim.new(0, 8)
applyCorner.Parent = applyBtn

-- Mode Indicator (shows if bypass is active)
local modeIndicator = Instance.new("TextLabel")
modeIndicator.Size = UDim2.new(0, 60, 0, 18)
modeIndicator.Position = UDim2.new(1, -70, 0, 8)
modeIndicator.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
modeIndicator.BorderSizePixel = 0
modeIndicator.Font = Enum.Font.GothamBold
modeIndicator.TextSize = 10
modeIndicator.TextColor3 = Color3.fromRGB(255, 200, 100)
modeIndicator.Text = "DIRECT"
modeIndicator.Parent = speedContainer

local modeCorner = Instance.new("UICorner")
modeCorner.CornerRadius = UDim.new(0, 4)
modeCorner.Parent = modeIndicator

-- Debug Label (shows what's happening)
debugLabel = Instance.new("TextLabel")
debugLabel.Size = UDim2.new(1, -20, 0, 15)
debugLabel.Position = UDim2.new(0, 10, 1, -20)
debugLabel.BackgroundTransparency = 1
debugLabel.Font = Enum.Font.Code
debugLabel.TextSize = 10
debugLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
debugLabel.Text = "Ready"
debugLabel.TextXAlignment = Enum.TextXAlignment.Left
debugLabel.Parent = speedContainer

-- Make draggable from drag handle ONLY
local dragging = false
local dragStart
local startPos

dragHandle.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = speedContainer.Position
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

dragHandle.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			local delta = input.Position - dragStart
			speedContainer.Position = UDim2.new(
				startPos.X.Scale, 
				startPos.X.Offset + delta.X,
				startPos.Y.Scale, 
				startPos.Y.Offset + delta.Y
			)
		end
	end
end)

-- Speed application functions
local function applyDirectSpeed(speed)
	if humanoid then
		humanoid.WalkSpeed = speed
		return true
	end
	return false
end

local function applyBypassSpeed(speed)
	if not humanoid or not hrp then return false end
	
	bypassMode = true
	modeIndicator.Text = "BYPASS"
	modeIndicator.TextColor3 = Color3.fromRGB(255, 100, 100)
	
	-- Always create BodyVelocity (used by Method 1 and 3)
	if not bodyVelocity or bodyVelocity.Parent ~= hrp then
		bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.MaxForce = Vector3.new(100000, 0, 100000)
		bodyVelocity.Velocity = Vector3.zero
		bodyVelocity.Parent = hrp
	end
	
	debugLabel.Text = "Bypass active - Method " .. bypassMethod
	
	return true
end

local function checkIfSpeedLocked()
	if not humanoid then return false end
	
	-- Try to set speed
	local testSpeed = humanoid.WalkSpeed + 1
	humanoid.WalkSpeed = testSpeed
	
	task.wait(0.1)
	
	-- Check if it was reverted
	if math.abs(humanoid.WalkSpeed - testSpeed) > 0.5 then
		-- Speed was locked, restore default
		humanoid.WalkSpeed = DEFAULT_SPEED
		return true
	else
		-- Speed change worked, restore default
		humanoid.WalkSpeed = DEFAULT_SPEED
		return false
	end
end

-- Apply button action
applyBtn.Activated:Connect(function()
	local inputText = speedInput.Text
	local speed = tonumber(inputText)
	
	if not speed then
		applyBtn.Text = "INVALID!"
		applyBtn.BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		task.wait(1)
		applyBtn.Text = "APPLY"
		applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
		return
	end
	
	-- Clamp speed
	speed = math.clamp(speed, 0, 500)
	currentSpeed = speed
	
	-- Try direct method first
	applyDirectSpeed(speed)
	
	-- Check if it's locked
	task.wait(0.3)
	local isLocked = checkIfSpeedLocked()
	
	if isLocked then
		-- Speed is locked, use bypass
		warn("[Speed Customizer] Direct method blocked - Using Bypass Method " .. bypassMethod)
		applyBypassSpeed(speed)
		
		applyBtn.Text = "BYP M" .. bypassMethod
		applyBtn.BackgroundColor3 = Color3.fromRGB(255, 140, 60)
		modeIndicator.Text = "BYP-" .. bypassMethod
		
		debugLabel.Text = "Testing bypass..."
	else
		-- Direct worked
		bypassMode = false
		modeIndicator.Text = "DIRECT"
		modeIndicator.TextColor3 = Color3.fromRGB(100, 255, 100)
		applyBtn.Text = "APPLIED"
		applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
		
		debugLabel.Text = "Direct mode OK"
	end
	
	isSpeedActive = true
	
	task.wait(2)
	if isSpeedActive then
		if bypassMode then
			applyBtn.Text = "BYP M" .. bypassMethod
		else
			applyBtn.Text = "ACTIVE"
		end
	end
end)

-- Bypass mode - Simplified and more reliable
local lastCFrameUpdate = tick()

RunService.Heartbeat:Connect(function(dt)
	-- Only run when bypass is active
	if not bypassMode or not isSpeedActive then
		if debugLabel then
			debugLabel.Text = "Inactive"
		end
		return
	end
	
	if not humanoid or not hrp then
		if debugLabel then
			debugLabel.Text = "No char"
		end
		return
	end
	
	-- Check humanoid state
	local state = humanoid:GetState()
	if state == Enum.HumanoidStateType.Dead or 
	   state == Enum.HumanoidStateType.Physics or
	   state == Enum.HumanoidStateType.Swimming then
		if debugLabel then
			debugLabel.Text = "Bad state"
		end
		return
	end
	
	-- Get movement direction
	local moveVector = humanoid.MoveVector
	local isMoving = moveVector.Magnitude > 0.05
	
	if debugLabel then
		debugLabel.Text = string.format("M%d Moving:%s Spd:%.0f", bypassMethod, tostring(isMoving), currentSpeed)
	end
	
	if not isMoving then
		-- Not moving, reset velocity
		if bodyVelocity and bodyVelocity.Parent then
			bodyVelocity.Velocity = Vector3.zero
		end
		return
	end
	
	-- Player is moving - apply bypass
	local speedMultiplier = currentSpeed / DEFAULT_SPEED
	local moveDirection = moveVector.Unit
	
	-- METHOD 1: BodyVelocity (simple velocity boost)
	if bypassMethod == 1 then
		if bodyVelocity and bodyVelocity.Parent then
			local targetSpeed = currentSpeed
			local currentY = hrp.AssemblyLinearVelocity.Y
			bodyVelocity.Velocity = Vector3.new(
				moveDirection.X * targetSpeed,
				currentY,
				moveDirection.Z * targetSpeed
			)
		end
	end
	
	-- METHOD 2: CFrame (direct position manipulation)
	if bypassMethod == 2 then
		-- Calculate how much extra distance we need per frame
		local normalMove = DEFAULT_SPEED * dt
		local wantedMove = currentSpeed * dt
		local extraMove = wantedMove - normalMove
		
		-- Apply the extra movement via CFrame
		if extraMove > 0 then
			local newPos = hrp.Position + (moveDirection * extraMove)
			hrp.CFrame = CFrame.new(newPos) * (hrp.CFrame - hrp.CFrame.Position)
		end
	end
	
	-- METHOD 3: Hybrid (gentle CFrame + velocity)
	if bypassMethod == 3 then
		-- Small CFrame nudge
		local nudgeAmount = (currentSpeed - DEFAULT_SPEED) * dt * 0.4
		if nudgeAmount > 0 then
			local newPos = hrp.Position + (moveDirection * nudgeAmount)
			hrp.CFrame = CFrame.new(newPos) * (hrp.CFrame - hrp.CFrame.Position)
		end
		
		-- Plus velocity boost
		if bodyVelocity and bodyVelocity.Parent then
			local boostSpeed = currentSpeed * 0.6
			local currentY = hrp.AssemblyLinearVelocity.Y
			bodyVelocity.Velocity = Vector3.new(
				moveDirection.X * boostSpeed,
				currentY,
				moveDirection.Z * boostSpeed
			)
		end
	end
end)

-- Monitor for speed resets (anti-tamper)
spawn(function()
	while true do
		task.wait(0.5)
		
		if isSpeedActive and not bypassMode and humanoid then
			-- Check if speed was reset by game
			if math.abs(humanoid.WalkSpeed - currentSpeed) > 2 then
				-- Speed was tampered with, reapply
				humanoid.WalkSpeed = currentSpeed
			end
		end
	end
end)

print("Mobile Speed Customizer [DEBUG MODE] loaded!")
print("âœ… Direct mode: Works in most games")
print("âœ… Bypass Method 1: BodyVelocity boost")
print("âœ… Bypass Method 2: CFrame manipulation (DEFAULT)")
print("âœ… Bypass Method 3: Hybrid approach")
print("ðŸ’¡ Type speed & click APPLY")
print("ðŸ”§ Click mode indicator to switch bypass methods")
print("ðŸ“Š Debug label shows what's happening")
