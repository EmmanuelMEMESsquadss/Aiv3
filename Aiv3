-- LocalScript (StarterPlayerScripts)
-- Mobile Speed Customizer with Anti-Protection Bypass

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Only run on mobile
if not UserInputService.TouchEnabled then
	return
end

local player = Players.LocalPlayer
local character, humanoid, hrp

local DEFAULT_SPEED = 16
local currentSpeed = DEFAULT_SPEED
local isSpeedActive = false
local bypassMode = false
local bypassMethod = 1  -- 1 = Velocity, 2 = CFrame, 3 = Hybrid

-- Speed bypass objects
local bodyVelocity
local lastPosition
local lastUpdateTime = 0

local function setupCharacter(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")
	
	-- Store default speed
	if humanoid then
		DEFAULT_SPEED = humanoid.WalkSpeed
	end
	
	-- Clean up old velocity if exists
	if bodyVelocity then
		bodyVelocity:Destroy()
		bodyVelocity = nil
	end
end

if player.Character then setupCharacter(player.Character) end
player.CharacterAdded:Connect(setupCharacter)

-- GUI
local gui = Instance.new("ScreenGui")
gui.Name = "SpeedCustomizerUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- Main Speed Container (just a visual wrapper)
local speedContainer = Instance.new("Frame")
speedContainer.Size = UDim2.new(0, 140, 0, 120)
speedContainer.Position = UDim2.new(0.85, -140, 0.5, -60)
speedContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
speedContainer.BorderSizePixel = 0
speedContainer.Active = false  -- Not interactive itself
speedContainer.Parent = gui

local containerCorner = Instance.new("UICorner")
containerCorner.CornerRadius = UDim.new(0, 12)
containerCorner.Parent = speedContainer

-- Drag Handle Area (ONLY for dragging)
local dragHandle = Instance.new("Frame")
dragHandle.Size = UDim2.new(1, 0, 0, 33)
dragHandle.Position = UDim2.new(0, 0, 0, 0)
dragHandle.BackgroundTransparency = 1  -- Invisible, just for dragging
dragHandle.Active = true  -- Can receive input
dragHandle.Parent = speedContainer

-- Title Label (inside drag handle)
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, -20, 1, 0)
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "SPEED"
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.Parent = dragHandle

-- Speed Input Box
local speedInput = Instance.new("TextBox")
speedInput.Size = UDim2.new(1, -20, 0, 35)
speedInput.Position = UDim2.new(0, 10, 0, 38)
speedInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
speedInput.BorderSizePixel = 0
speedInput.Font = Enum.Font.GothamBold
speedInput.TextSize = 20
speedInput.TextColor3 = Color3.new(1, 1, 1)
speedInput.PlaceholderText = "16"
speedInput.Text = ""
speedInput.ClearTextOnFocus = false
speedInput.TextXAlignment = Enum.TextXAlignment.Center
speedInput.Parent = speedContainer

local inputCorner = Instance.new("UICorner")
inputCorner.CornerRadius = UDim.new(0, 8)
inputCorner.Parent = speedInput

-- Apply Button
local applyBtn = Instance.new("TextButton")
applyBtn.Size = UDim2.new(1, -20, 0, 32)
applyBtn.Position = UDim2.new(0, 10, 0, 80)
applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
applyBtn.BorderSizePixel = 0
applyBtn.Font = Enum.Font.GothamBold
applyBtn.TextSize = 14
applyBtn.TextColor3 = Color3.new(1, 1, 1)
applyBtn.Text = "APPLY"
applyBtn.Parent = speedContainer

local applyCorner = Instance.new("UICorner")
applyCorner.CornerRadius = UDim.new(0, 8)
applyCorner.Parent = applyBtn

-- Mode Indicator (shows if bypass is active)
local modeIndicator = Instance.new("TextLabel")
modeIndicator.Size = UDim2.new(0, 60, 0, 18)
modeIndicator.Position = UDim2.new(1, -70, 0, 8)
modeIndicator.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
modeIndicator.BorderSizePixel = 0
modeIndicator.Font = Enum.Font.GothamBold
modeIndicator.TextSize = 10
modeIndicator.TextColor3 = Color3.fromRGB(255, 200, 100)
modeIndicator.Text = "DIRECT"
modeIndicator.Parent = speedContainer

local modeCorner = Instance.new("UICorner")
modeCorner.CornerRadius = UDim.new(0, 4)
modeCorner.Parent = modeIndicator

-- Make draggable from drag handle ONLY
local dragging = false
local dragStart
local startPos

dragHandle.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = speedContainer.Position
		
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

dragHandle.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			local delta = input.Position - dragStart
			speedContainer.Position = UDim2.new(
				startPos.X.Scale, 
				startPos.X.Offset + delta.X,
				startPos.Y.Scale, 
				startPos.Y.Offset + delta.Y
			)
		end
	end
end)

-- Speed application functions
local function applyDirectSpeed(speed)
	if humanoid then
		humanoid.WalkSpeed = speed
		return true
	end
	return false
end

local function applyBypassSpeed(speed)
	if not humanoid or not hrp then return false end
	
	bypassMode = true
	modeIndicator.Text = "BYPASS"
	modeIndicator.TextColor3 = Color3.fromRGB(255, 100, 100)
	
	-- Try Method 1: Enhanced BodyVelocity
	if bypassMethod == 1 then
		if not bodyVelocity or bodyVelocity.Parent ~= hrp then
			bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.MaxForce = Vector3.new(math.huge, 0, math.huge)  -- Stronger force
			bodyVelocity.P = 5000  -- High power
			bodyVelocity.Parent = hrp
		end
	end
	
	lastPosition = hrp.Position
	lastUpdateTime = tick()
	
	return true
end

local function checkIfSpeedLocked()
	if not humanoid then return false end
	
	-- Try to set speed
	local testSpeed = humanoid.WalkSpeed + 1
	humanoid.WalkSpeed = testSpeed
	
	task.wait(0.1)
	
	-- Check if it was reverted
	if math.abs(humanoid.WalkSpeed - testSpeed) > 0.5 then
		-- Speed was locked, restore default
		humanoid.WalkSpeed = DEFAULT_SPEED
		return true
	else
		-- Speed change worked, restore default
		humanoid.WalkSpeed = DEFAULT_SPEED
		return false
	end
end

-- Apply button action
applyBtn.Activated:Connect(function()
	local inputText = speedInput.Text
	local speed = tonumber(inputText)
	
	if not speed then
		-- Invalid input
		applyBtn.Text = "INVALID!"
		applyBtn.BackgroundColor3 = Color3.fromRGB(206, 36, 36)
		task.wait(1)
		applyBtn.Text = "APPLY"
		applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
		return
	end
	
	-- Clamp speed to reasonable values
	speed = math.clamp(speed, 0, 500)
	currentSpeed = speed
	
	-- Try direct method first
	local success = applyDirectSpeed(speed)
	
	-- Check if speed is being locked by the game
	task.wait(0.2)
	local isLocked = checkIfSpeedLocked()
	
	if isLocked then
		-- Direct method failed, try bypass methods
		
		-- Try Method 1 first (BodyVelocity)
		bypassMethod = 1
		applyBypassSpeed(speed)
		
		-- Wait and test if Method 1 works
		task.wait(0.5)
		local method1Works = (hrp.AssemblyLinearVelocity.Magnitude > DEFAULT_SPEED * 0.8) and (humanoid.MoveVector.Magnitude > 0.1)
		
		if not method1Works then
			-- Method 1 failed, try Method 2 (CFrame)
			warn("Bypass Method 1 failed, switching to Method 2 (CFrame)")
			bypassMethod = 2
		end
		
		applyBtn.Text = "BYPASS M" .. bypassMethod
		applyBtn.BackgroundColor3 = Color3.fromRGB(255, 140, 60)
		modeIndicator.Text = "BYP-" .. bypassMethod
	else
		-- Direct method worked
		bypassMode = false
		modeIndicator.Text = "DIRECT"
		modeIndicator.TextColor3 = Color3.fromRGB(100, 255, 100)
		applyBtn.Text = "APPLIED"
		applyBtn.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
	end
	
	isSpeedActive = true
	
	-- Reset button text
	task.wait(1.5)
	if isSpeedActive then
		if bypassMode then
			applyBtn.Text = "BYP M" .. bypassMethod
		else
			applyBtn.Text = "ACTIVE"
		end
	else
		applyBtn.Text = "APPLY"
	end
end)

-- Bypass mode - Multiple methods
RunService.Heartbeat:Connect(function(dt)
	if not bypassMode or not isSpeedActive or not humanoid or not hrp then
		return
	end
	
	-- Check if humanoid is in a state where we should apply speed
	local state = humanoid:GetState()
	if state == Enum.HumanoidStateType.Dead or 
	   state == Enum.HumanoidStateType.Physics or
	   state == Enum.HumanoidStateType.Swimming or
	   state == Enum.HumanoidStateType.Climbing then
		return
	end
	
	local moveVector = humanoid.MoveVector
	
	if moveVector.Magnitude > 0.1 then
		local speedMultiplier = currentSpeed / DEFAULT_SPEED
		
		-- METHOD 1: Enhanced BodyVelocity (for games with weak protection)
		if bypassMethod == 1 and bodyVelocity and bodyVelocity.Parent then
			local targetVelocity = moveVector * currentSpeed
			bodyVelocity.Velocity = Vector3.new(targetVelocity.X, hrp.AssemblyLinearVelocity.Y, targetVelocity.Z)
		end
		
		-- METHOD 2: CFrame Manipulation (for heavily protected games)
		if bypassMethod == 2 then
			local currentTime = tick()
			local timeDelta = currentTime - lastUpdateTime
			
			if timeDelta > 0 then
				-- Calculate how far we should move based on speed
				local normalDistance = DEFAULT_SPEED * timeDelta
				local boostedDistance = currentSpeed * timeDelta
				local extraDistance = boostedDistance - normalDistance
				
				-- Apply the extra distance via CFrame
				local moveDirection = moveVector.Unit
				local newCFrame = hrp.CFrame + (moveDirection * extraDistance)
				
				-- Smooth teleport (less detectable)
				hrp.CFrame = hrp.CFrame:Lerp(newCFrame, 0.7)
				
				lastUpdateTime = currentTime
			end
		end
		
		-- METHOD 3: Hybrid (combines both for maximum effectiveness)
		if bypassMethod == 3 then
			-- Small CFrame boost
			local moveDirection = moveVector.Unit
			local boostAmount = (currentSpeed - DEFAULT_SPEED) * dt * 0.3
			hrp.CFrame = hrp.CFrame + (moveDirection * boostAmount)
			
			-- Plus velocity assistance
			if bodyVelocity and bodyVelocity.Parent then
				local targetVelocity = moveVector * (currentSpeed * 0.7)
				bodyVelocity.Velocity = Vector3.new(targetVelocity.X, hrp.AssemblyLinearVelocity.Y, targetVelocity.Z)
			end
		end
	else
		-- Not moving, disable velocity
		if bodyVelocity and bodyVelocity.Parent then
			bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		end
	end
end)

-- Monitor for speed resets (anti-tamper)
spawn(function()
	while true do
		task.wait(0.5)
		
		if isSpeedActive and not bypassMode and humanoid then
			-- Check if speed was reset by game
			if math.abs(humanoid.WalkSpeed - currentSpeed) > 2 then
				-- Speed was tampered with, reapply
				humanoid.WalkSpeed = currentSpeed
			end
		end
	end
end)

print("Mobile Speed Customizer [MULTI-BYPASS] loaded!")
print("âœ… Direct mode for most games")
print("âœ… Bypass Method 1: Enhanced BodyVelocity")
print("âœ… Bypass Method 2: CFrame manipulation (for heavy protection)")
print("âœ… Bypass Method 3: Hybrid approach")
print("ðŸ’¡ Drag from title bar | Type speed & click APPLY")
print("ðŸ”§ Auto-detects best bypass method")
